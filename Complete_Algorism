#include <3052.h>
#define RX_BUFFER_SIZE 256
#define TX_BUFFER_SIZE 256
//////////////ライントレースのライブラリ始まり////////////////
#define Kp          (4)    //ライントレースの定数// 比例ゲイン
#define Kd          (4)    // 微分制御
#define Duty_base   (70)        //基本制御のDuty比(%)
#define Duty_width  (20)         //Duty比振れ幅(%)
#define Target_ref  (986)       //目標PR値 pr1,pr2の平均値
//-------------------------------------
// #define STOP (1006) //銀テープ検知の定義pr値
//--------------------------------------
void quater_msecwait(){
 int t =17;
 while(t--);
 }
void wait(void){
  int t=500;
  while(t--);
}
int readPr1(){
  int i; long sum=0;
  for(i = 0; i < 50; i ++){
    AD.ADCSR.BIT.ADF=0;  // フラグクリア
    AD.ADCSR.BIT.ADST=1;          //変換スタート
    while(AD.ADCSR.BIT.ADF==0);     //変換が終わるまで待つ
    sum += AD.ADDRA >> 6;   //Port7,0
    AD.ADCSR.BIT.ADF=0;    //フラグクリア
  }
  return sum/50; 
}
int readPr2(){
  int i; long sum=0;
  for(i = 0; i < 50; i ++){
    AD.ADCSR.BIT.ADF=0;  // フラグクリア
    AD.ADCSR.BIT.ADST=1;          //変換スタート
    while(AD.ADCSR.BIT.ADF==0);     //変換が終わるまで待つ
    sum += AD.ADDRB >> 6;   //Port7,0
    AD.ADCSR.BIT.ADF=0;    //フラグクリア
  }
  return sum/50; 
}
int readPr3(){
  int i; long sum=0;
  for(i = 0; i < 50; i ++){
    AD.ADCSR.BIT.ADF=0;  // フラグクリア
    AD.ADCSR.BIT.ADST=1;          //変換スタート
    while(AD.ADCSR.BIT.ADF==0);     //変換が終わるまで待つ
    sum += AD.ADDRC >> 6;   //Port7,0
    AD.ADCSR.BIT.ADF=0;    //フラグクリア
  }
  return sum/50; 
}
//初期設定-------------------------------
void ioinit_MD(){
  PA.DDR = 0xff;//ポートA出力
  PB.DDR = 0xff;//ポートB出力
    }
void ituinit_ITU(){    //MD用PWM出力初期設定
  ITU0.TCR.BYTE = 0x23;
  ITU1.TCR.BYTE = 0x23;
  ITU2.TCR.BYTE = 0x23;
  ITU3.TCR.BYTE = 0x23;
  ITU.TMDR.BIT.PWM0 = 1;
  ITU.TMDR.BIT.PWM1 = 1;
  ITU.TMDR.BIT.PWM2 = 1;
  ITU.TMDR.BIT.PWM3 = 1;
  ITU0.GRA = 10000;
  ITU1.GRA = 10000;
  ITU2.GRA = 10000;
  ITU3.GRA = 10000;
  ITU0.GRB = 1;
  ITU1.GRB = 1;
  ITU2.GRB = 1;
  ITU3.GRB = 1;    
}
void adinit_CH1(){
  AD.ADCSR.BIT.ADF = 0;     //PR     
  AD.ADCSR.BIT.SCAN = 1;
  AD.ADCSR.BIT.CKS = 1;
  AD.ADCSR.BIT.CH = 1;//P7-0,P7-1,P7-2ピン利用 CN2 12pin & CN2 13pin //PR
}
void linetraceinit(){
  ioinit_MD();
  ituinit_ITU();
  adinit_CH1();
}
//制御用関数------------------------------
void motor_start(int a0){
    PA.DR.BIT.B2=a0;  
    PA.DR.BIT.B4=~a0;
    PA.DR.BIT.B6=a0;
    PB.DR.BIT.B2=~a0;
    wait();
} 
void motor_stop(void){
    PA.DR.BIT.B2=0;  
    PA.DR.BIT.B4=0;
    PA.DR.BIT.B6=0;
    PB.DR.BIT.B2=0;
}
void Pcontrl(int a0,int a1,int a2,int pr1,int pr2,int pr1_old,int pr2_old){  
    int dutycntrl1;
    int dutycntrl2; //モーター1に対して制御 //ifで分岐。銀テープが来たらモーターの回転を止める
    dutycntrl1=(Target_ref - pr1)*Kp+(pr1-pr1_old)*Kd;//duty制御量の算出 //理想的には0になるべき値 
    if(dutycntrl1>Duty_width){  //Duty_wifth大きくしたほうが良いかも
        dutycntrl1=Duty_width;
      }
    else if(dutycntrl1<-Duty_width){
      dutycntrl1=-Duty_width;
    }
    dutycntrl2=(Target_ref - pr2)*Kp+(pr2-pr2_old)*Kd;//duty制御量の算出 //理想的には0になるべき値
    if(dutycntrl2>Duty_width){
      dutycntrl2=Duty_width;
    }
    else if(dutycntrl2<-Duty_width){
      dutycntrl2=-Duty_width;
    }
    motor_start(a0);
    if(a0==1){
      if(a1*a2==0){
        ITU0.GRB=100*(Duty_base + dutycntrl1*a1 - dutycntrl2*a2);  //    (a1-a2) + 
        ITU2.GRB=100*(Duty_base + dutycntrl2*a2 - dutycntrl1*a1);  // (a0,a1,a2) a0=1,直進  a0=0,後進 a1=1,
      }
      else if(a1*a2==1){
      ITU0.GRB=100*(Duty_base + dutycntrl1*a1);  //    (a1-a2) + 
      ITU2.GRB=100*(Duty_base + dutycntrl2*a2);  // (a0,a1,a2) a0=1,直進  a0=0,後進 a1=1,
      }
    }   //前進します
    else if(a0==0){
      if(a1*a2==0){
      ITU1.GRB=100*(Duty_base + dutycntrl1*a1 - dutycntrl2*a2);
      ITU3.GRB=100*(Duty_base + dutycntrl2*a2 - dutycntrl1*a1);
      }
      else if(a1*a2){
      ITU1.GRB=100*(Duty_base + dutycntrl1*a1 );
      ITU3.GRB=100*(Duty_base + dutycntrl2*a2 );
      }  //後進します
    }
    SCI1_PRINTF("ITU0.GRB=%d\n",ITU0.GRB);
    SCI1_PRINTF("ITU1.GRB=%d\n",ITU1.GRB);
    SCI1_PRINTF("ITU2.GRB=%d\n",ITU2.GRB);
    SCI1_PRINTF("ITU3.GRB=%d\n",ITU3.GRB);
    ITU.TSTR.BIT.STR0 = 1;
    ITU.TSTR.BIT.STR1 = 1;
    ITU.TSTR.BIT.STR2 = 1;
    ITU.TSTR.BIT.STR3 = 1;  // PWM信号出力開始
    SCI1_PRINTF("OK\n");
    }
////////////////ライントレースの自作関数終わり////////////////////
////////////////距離測定センサ自作関数開始///////////////
//とりあえずTrigはPA-0、EchoはPA-1につなぐ。PortAでなくてもできると思う
//イニシャライズ関数
void ultrasonicinit(void){   //ポートのイニシャライズ
  P8.DDR = 0x01; //P8-0(Trig)は出力、P8-2(Echo)は入力//ITUのイニシャライズ
  P8.DR.BYTE = 0x00; //最初はEcho,TrigともにLow(0)
}
//precisely  xマイクロ秒待機する関数
void micro_wait(int x){
  ITU4.TCR.BYTE = 0x20; //超音波を出す時間を制御する  1/1,GRA==tcntの時にtcntクリア//p.114参照。GRAコンペアマッチでTCNTクリア//立ち上がりエッジでカウント、内部クロックそのままでカウント
  ITU4.GRA = x * 25; //1カウントで0.04μsだから25カウントで1μs
  ITU.TSTR.BIT.STR4 = 1; //タイマースタート
  while (!(ITU4.TSR.BIT.IMFA)); //フラグが立つ、つまり設定した時間が経つまで待つ
  ITU.TSTR.BIT.STR4 = 0; //タイマーストップ
  ITU4.TCNT = 0; //タイマーリセット
  ITU4.TSR.BIT.IMFA = 0; //フラグクリア
}
//距離を測定する周期を決める関数
//micro_waitは2msくらいしか計れないので別の関数を使う
//正確な制御はいらないのでタイマーは使わない
void about_wait(int t){  
  while (t--){   
    int m = 100;
    while (m--);
  }
}
//測距センサを動かす関数
void getCount(long *c){ //p.114参照。GRAなどによるTCNTクリア禁止 //立ち上がりエッジでカウント、内部クロックの1/8でカウント
  P8.DR.BIT.B0 = 1; //TrigをHigh(1)にして超音波を出力
  micro_wait(20); //超音波を20μs出す  //ITUのイニシャライズ
  ITU4.TCR.BYTE = 0x03; //超音波が反射するのにかかる時間を計測するタイマ 
  P8.DR.BIT.B0 = 0; //TrigをLow(0)にして超音波を出すのをやめる
  while (P8.DR.BIT.B2 == 0); //Echoの立ち上がりを待つ   //超音波を出し終わると同時にEchoが勝手に始動してHigh(1)になるSCI1_PRINTF("Echo high \n");
  ITU.TSTR.BIT.STR4 = 1; //タイマースタート
  while (P8.DR.BIT.B2 == 1); //Echoの立ち下がり、つまり反射した超音波を検出するのを待つ //反射した超音波を検出するとEchoが勝手にLow(0)になる SCI1_PRINTF("Echo low \n");
  *c = ITU4.TCNT; //タイマーの値をcountに格納
  ITU.TSTR.BIT.STR4 = 0; //タイマーストップ
  ITU4.TCNT = 0; //タイマーリセット  SCI1_PRINTF("%ld\n", count);
}
//カウンタの値を距離に変換
void convertCD(long count,long *d){   
  *d = count;
  *d *= 0.32; //カウンタの値を時間(マイクロ秒)に変換。カウント1回で0.32μs。
  *d /= 2; //往復の時間を半分にして片道の時間にする
  *d *= 340; //1マイクロ秒あたりの距離(m)を算出。音速は340m/sとする
  *d *= 100; //mをcmに変換
  *d /= 1000000; //1秒あたりの距離を算出//countはlong型なので先に100万で割ると0になってしまう
}
long readD1(){   
    long  count; //タイマーのカウント数を格納する変数
    long  distance; //距離を格納する変数
    getCount(&count); //距離を測定
    convertCD(count,&distance); //カウンタの値を距離に変換 SCI1_PRINTF("%ldcm\n", distance); //distanceに必要な値が格納された
    return distance;
}
/////////////////////距離測定センサ//////////////////////////
int detectSilver(int pr1,int pr2){
    if (pr1>1006 || pr2>1006){
      return 1;
    }
    else{
      return 0;
    }
}
int detectDistance(long d1){
    if (d1 < 6){ //5cm以下
      return 1;
    }
    else {
      return 0;
    }
} 
int decidePr3(int pr3){
  if(pr3>1000){
    return 1;
  }
  else if(pr3<=1000){
    return -1;
  }
  return 0;
}
int main(){
  int mode=0;
    //switch検知やEEPROMの初期設定をする初期設定が終わったらmode=1;にする
  mode=1;
  int pr1;int pr2; int pr1_old; int pr2_old; int pr3; int sflag=0; int dflag=0;int color=0;long d1=0;
  adinit_CH1(); 
  ioinit_MD();
  ituinit_ITU();
  ultrasonicinit();
  pr1_old=readPr1(); pr2_old=readPr2();//  初期設定
  while(1){
    switch(mode){
      case 1:   //スタート位置から、両方のPrを使ったライントレース  缶を先に見つけたらmode2;銀テープを先に検知したらGOALでmode10;
        color=0; //初期化
        dflag=0;
        sflag=0;
        while(dflag==0&&sflag==0){
          pr1=readPr1(); pr2=readPr2();//0~1023;
          sflag = detectSilver(pr1,pr2);// 銀テープを検知したらsflagを立てる
          d1=readD1(); //cm //int sflag=0; 
          dflag = detectDistance(d1);   //缶を検知したらdflagを立てる
          if(dflag==1){        // dflag==1;のとき缶の色を検知しcolorに代入
            pr3=readPr3();
            color = decidePr3(pr3);
          }
          Pcontrl(1,1,1,pr1,pr2,pr1_old,pr2_old);   //直進、両方のPrを用いたライントレース(a0,a1,a2,pr1,pr2)
          wait();   //この時間だけライントレースをする
          pr1_old=pr1;
          pr2_old=pr2;
        }
        if(dflag==1){
          mode=2; //缶を見つけたらwhile文を抜けてmode2へ移行
        }
        else if(sflag==1){
          mode=10;
        }
      break;
      
    case 2:  //缶を見つけた後に、バックする
      sflag=0;
      while(sflag==0){ 
        pr1=readPr1(); pr2=readPr2();//0~1023;
        sflag = detectSilver(pr1,pr2); //もし銀テープをどちらかのPrで検知したらsflag=1;にする
         Pcontrl(0,1,1,pr1,pr2,pr1_old,pr2_old);   //後進、Pr2を用いたライントレース(a0,a1,a2,pr1,pr2)
        wait();    //この時間だけライントレースをする
        pr1_old=pr1; pr2_old=pr2;
      }
      mode=3; //銀テープを見つけたらwhile文を抜けてmode3へ移行
     break;
     
    case 3:  //銀テープを検知したあとに方向転換の場所に入り、Pr2のみを用いて後進する
      sflag=0;
      while(sflag==0){
        pr1=readPr1(); pr2=readPr2();//0~1023;
        dflag = detectSilver(pr1,pr2); //もし銀テープをどちらかのPrで検知したらsflag=1;にする
         Pcontrl(0,0,1,pr1,pr2,pr1_old,pr2_old);    //後進、Pr2を用いたライントレース(a0,a1,a2,pr1,pr2)
        wait();    //この時間だけライントレースをする
         pr1_old=pr1; pr2_old=pr2;
      }
      mode=4; //銀テープを見つけたらwhile文を抜けてmode3へ移行
      break;
      
    case 4:  // 銀テープを検知した後にPr1のみを用いて前進する
       sflag=0;
       while(sflag==0){
         pr1=readPr1(); pr2=readPr2();//0~1023;
         sflag = detectSilver(pr1,pr2); //もし銀テープをどちらかのPrで検知したらsflag=1;にする
          Pcontrl(1,1,0,pr1,pr2,pr1_old,pr2_old);    //直進、Pr1を用いたライントレース(a0,a1,a2,pr1,pr2)
         wait();    //この時間だけライントレースをする
          pr1_old=pr1; pr2_old=pr2;
      }
      mode=5; //銀テープを見つけたらwhile文を抜けてmode4へ移行
      break;
      
    case 5:  //銀テープを検知した後にcolorが1,-1かによって分岐をする,colorの値によってa1,a2の値を変える 
       sflag=0;
       while(sflag==0){
         pr1=readPr1(); pr2=readPr2();//0~1023;
         sflag = detectSilver(pr1,pr2); //もし銀テープをどちらかのPrで検知したらsflag=1;にする
         if(color==1){ //銀色の缶を持っている場合
          Pcontrl(1,1,0,pr1,pr2,pr1_old,pr2_old);    //直進、Pr1を用いたライントレース(a0,a1,a2,pr1,pr2)
         wait();    //この時間だけライントレースをする
         }
         else if(color==-1){
          Pcontrl(1,0,1,pr1,pr2,pr1_old,pr2_old);    //直進、pr2を用いたライントレース
         wait();
         }
          pr1_old=pr1; pr2_old=pr2;
       }
       mode = 6;   //缶捨て場に到着したらmode6へ移行
      break;
      
    case 6:  // 銀テープを検知した後に微移動する
      dflag=1;   //缶を落とすまで前に少し移動する予定
      while(dflag==1){
        pr1=readPr1(); pr2=readPr2();//0~1023;
        long  d1; 
        d1=readD1();
        dflag =  detectDistance(d1);   //缶を捨てたらdflag=0;
        Pcontrl(1,1,1,pr1,pr2,pr1_old,pr2_old);    //直進、両方のPrを用いたライントレース(a0,a1,a2,pr1,pr2)
        wait();    //この時間だけライントレースをする
        Pcontrl(0,1,1,pr1,pr2,pr1_old,pr2_old);
        wait();
        pr1_old=pr1; pr2_old=pr2;
       }
       mode=7;
      break;
      
    case 7:// 缶を落としたら、分岐を後進する
        sflag=0;
        while(sflag==0){ 
          pr1=readPr1(); pr2=readPr2();//0~1023;
          sflag = detectSilver(pr1,pr2); //もし銀テープをどちらかのPrで検知したらsflag=1;にする
          if(color==1){ //銀色の缶を持っていた場合
           Pcontrl(0,1,0,pr1,pr2,pr1_old,pr2_old);    //後進、Pr1を用いたライントレース(a0,a1,a2,pr1,pr2)
         wait();    //この時間だけライントレースをする
         }
         else if(color==-1){
         Pcontrl(0,0,1,pr1,pr2,pr1_old,pr2_old);   //後進、pr2を用いたライントレース
         wait();
         pr1_old=pr1; pr2_old=pr2;
         }
       }
       mode = 8;//へ移行
      break;
      
    case 8:  //銀テープを検知したら、方向転換に入るので、Pr1だけを使って後進する
        sflag=0;
        while(sflag==0){
          pr1=readPr1(); pr2=readPr2();//0~1023;
          sflag = detectSilver(pr1,pr2); //もし銀テープをどちらかのPrで検知したらsflag=1;にする
          Pcontrl(0,1,0,pr1,pr2,pr1_old,pr2_old);    //後進、Pr1を用いたライントレース(a0,a1,a2,pr1,pr2)
          wait();    //この時間だけライントレースをする
          pr1_old=pr1; pr2_old=pr2;
         }
       mode = 9;//へ移行
       break;
       
    case 9: //銀テープを検知したら、Pr2のみを用いて前進する,case9:が終わると初期位置に戻る
          sflag=0;
          while(sflag==0){ 
          pr1=readPr1(); pr2=readPr2();//0~1023;
          sflag = detectSilver(pr1,pr2); //もし銀テープをどちらかのPrで検知したらsflag=1;にする
           Pcontrl(1,0,1,pr1,pr2,pr1_old,pr2_old);    //後進、Pr1を用いたライントレース(a0,a1,a2,pr1,pr2)
          wait();    //この時間だけライントレースをする
          pr1_old=pr1; pr2_old=pr2;
         }
         mode = 1;//へ移行
         break;
         
     case 10://  
         //LEDを点灯させてゴール break無し
         motor_stop();
         break;
    }
}
 return 0;
};
