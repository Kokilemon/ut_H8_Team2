#include <3052.h>
#define RX_BUFFER_SIZE 256
#define TX_BUFFER_SIZE 256
//////////////ライントレースの自作関数始まり////////////////
#define Kp          (4)    //ライントレースの定数// 比例ゲイン
#define Kd          (4)    // 微分制御
#define Duty_base   (70)        //基本制御のDuty比(%)
#define Duty_width  (20)         //Duty比振れ幅(%)
#define Target_ref  (986)       //目標PR値 pr1,pr2の平均値
//-------------------------------------
// #define STOP (1006) //銀テープ検知の定義pr値
//--------------------------------------
void quater_msecwait(){
 int t =17;
 while(t--);
 }
void wait(void){
  int t=500;
  while(t--);
}
int readPr1(){
  int i; long sum=0;
  for(i = 0; i < 50; i ++){
    AD.ADCSR.BIT.ADF=0;  // フラグクリア
    AD.ADCSR.BIT.ADST=1;          //変換スタート
    while(AD.ADCSR.BIT.ADF==0);     //変換が終わるまで待つ
    sum += AD.ADDRA >> 6;   //Port7,0
    AD.ADCSR.BIT.ADF=0;    //フラグクリア
  }
  return sum/50; 
}
int readPr2(){
  int i; long sum=0;
  for(i = 0; i < 50; i ++){
    AD.ADCSR.BIT.ADF=0;  // フラグクリア
    AD.ADCSR.BIT.ADST=1;          //変換スタート
    while(AD.ADCSR.BIT.ADF==0);     //変換が終わるまで待つ
    sum += AD.ADDRB >> 6;   //Port7,0
    AD.ADCSR.BIT.ADF=0;    //フラグクリア
  }
  return sum/50; 
}
int readPr3(){
  int i; long sum=0;
  for(i = 0; i < 50; i ++){
    AD.ADCSR.BIT.ADF=0;  // フラグクリア
    AD.ADCSR.BIT.ADST=1;          //変換スタート
    while(AD.ADCSR.BIT.ADF==0);     //変換が終わるまで待つ
    sum += AD.ADDRC >> 6;   //Port7,0
    AD.ADCSR.BIT.ADF=0;    //フラグクリア
  }
  return sum/50; 
}
//初期設定-------------------------------
void ioinit_MD(){
  PA.DDR = 0xff;//ポートA出力
  PB.DDR = 0xff;//ポートB出力
    }
void ituinit_ITU(){    //MD用PWM出力初期設定
  ITU0.TCR.BYTE = 0x23;
  ITU1.TCR.BYTE = 0x23;
  ITU2.TCR.BYTE = 0x23;
  ITU3.TCR.BYTE = 0x23;
  ITU.TMDR.BIT.PWM0 = 1;
  ITU.TMDR.BIT.PWM1 = 1;
  ITU.TMDR.BIT.PWM2 = 1;
  ITU.TMDR.BIT.PWM3 = 1;
  ITU0.GRA = 10000;
  ITU1.GRA = 10000;
  ITU2.GRA = 10000;
  ITU3.GRA = 10000;
  ITU0.GRB = 1;
  ITU1.GRB = 1;
  ITU2.GRB = 1;
  ITU3.GRB = 1;    
}
void adinit_CH1(){
  AD.ADCSR.BIT.ADF = 0;     //PR     
  AD.ADCSR.BIT.SCAN = 1;
  AD.ADCSR.BIT.CKS = 1;
  AD.ADCSR.BIT.CH = 1;//P7-0,P7-1,P7-2ピン利用 CN2 12pin & CN2 13pin //PR
}
void linetraceinit(){
  ioinit_MD();
  ituinit_ITU();
  adinit_CH1();
}
//制御用関数------------------------------
void motor_start(int a0){
    PA.DR.BIT.B2=a0;  
    PA.DR.BIT.B4=~a0;
    PA.DR.BIT.B6=a0;
    PB.DR.BIT.B2=~a0;
    wait();
} 
void motor_stop(void){
    PA.DR.BIT.B2=0;  
    PA.DR.BIT.B4=0;
    PA.DR.BIT.B6=0;
    PB.DR.BIT.B2=0;
}
void Pcontrl(int a0,int a1,int a2,int pr1,int pr2,int pr1_old,int pr2_old){  
    int dutycntrl1;
    int dutycntrl2; //モーター1に対して制御 //ifで分岐。銀テープが来たらモーターの回転を止める
    dutycntrl1=(Target_ref - pr1)*Kp+(pr1-pr1_old)*Kd;//duty制御量の算出 //理想的には0になるべき値 
    if(dutycntrl1>Duty_width){  //Duty_wifth大きくしたほうが良いかも
        dutycntrl1=Duty_width;
      }
    else if(dutycntrl1<-Duty_width){
      dutycntrl1=-Duty_width;
    }
    dutycntrl2=(Target_ref - pr2)*Kp+(pr2-pr2_old)*Kd;//duty制御量の算出 //理想的には0になるべき値
    if(dutycntrl2>Duty_width){
      dutycntrl2=Duty_width;
    }
    else if(dutycntrl2<-Duty_width){
      dutycntrl2=-Duty_width;
    }
    motor_start(a0);
    if(a0==1){
      if(a1*a2==0){
        ITU0.GRB=100*(Duty_base + dutycntrl1*a1 - dutycntrl2*a2);  //    (a1-a2) + 
        ITU2.GRB=100*(Duty_base + dutycntrl2*a2 - dutycntrl1*a1);  // (a0,a1,a2) a0=1,直進  a0=0,後進 a1=1,
      }
      else if(a1*a2==1){
      ITU0.GRB=100*(Duty_base + dutycntrl1*a1);  //    (a1-a2) + 
      ITU2.GRB=100*(Duty_base + dutycntrl2*a2);  // (a0,a1,a2) a0=1,直進  a0=0,後進 a1=1,
      }
    }   //前進します
    else if(a0==0){
      if(a1*a2==0){
      ITU1.GRB=100*(Duty_base + dutycntrl1*a1 - dutycntrl2*a2);
      ITU3.GRB=100*(Duty_base + dutycntrl2*a2 - dutycntrl1*a1);
      }
      else if(a1*a2){
      ITU1.GRB=100*(Duty_base + dutycntrl1*a1 );
      ITU3.GRB=100*(Duty_base + dutycntrl2*a2 );
      }  //後進します
    }
    SCI1_PRINTF("ITU0.GRB=%d\n",ITU0.GRB);
    SCI1_PRINTF("ITU1.GRB=%d\n",ITU1.GRB);
    SCI1_PRINTF("ITU2.GRB=%d\n",ITU2.GRB);
    SCI1_PRINTF("ITU3.GRB=%d\n",ITU3.GRB);
    ITU.TSTR.BIT.STR0 = 1;
    ITU.TSTR.BIT.STR1 = 1;
    ITU.TSTR.BIT.STR2 = 1;
    ITU.TSTR.BIT.STR3 = 1;  // PWM信号出力開始
    SCI1_PRINTF("OK\n");
    }


int main(void){
int pr1;int pr2; int pr1_old; int pr2_old; // int pr3; int sflag=0; int dflag=0;int color=0;long d1=0;
adinit_CH1(); 
ioinit_MD();
ituinit_ITU();
pr1_old=readPr1(); pr2_old=readPr2();//  初期設定

  static char rxb[RX_BUFFER_SIZE];
  static char txb[TX_BUFFER_SIZE];
  SCI1_INIT(br19200, txb, TX_BUFFER_SIZE, rxb, RX_BUFFER_SIZE);
  EI;
  while(1){  SCI1_PRINTF("whileStart\n");  
    pr1=readPr1(); pr2=readPr2();//0~1023; SCI1_PRINTF("pr1=%d\n",pr1); SCI1_PRINTF("pr2=%d\n",pr2); SCI1_PRINTF("pr1_old=%d\n",pr1_old); SCI1_PRINTF("pr2_old=%d\n",pr2_old);   
    
    Pcontrl(1,1,1,pr1,pr2,pr1_old,pr2_old);   //直進、両方のPrを用いたライントレース(a0,a1,a2,pr1,pr2)
    wait();   //この時間だけライントレースをする
    pr1_old=pr1; pr2_old=pr2;  SCI1_PRINTF("whileEnd\n");
    }
}
